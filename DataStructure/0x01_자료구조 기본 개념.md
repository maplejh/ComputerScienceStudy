## 1.1 개요:시스템 생명 주기

(1) 요구사항
프로젝트들의 목적을 정의한 명세들의 집합
-> 입력과 출력에 관한 정보를 정밀하게 기술

(2) 분석
실제로 다룰 수 있는 작은 단위로 나눈다.
상향식과 하향식 접근 방법으로 나눌 수 있다.
	상향식: 낮은 수준의 문제를 해결하고 더 큰 문제로 통합/ 모듈간의 상호작용이 필요하며 이후에 결합한다./캡슐화 할 데이터를 조사하고 정보 은닉의 개념을 구현한다. 중복정보를 포함하지 않는다/ 주로 객체 지향프로그래밍 언어가 이방식을 이용한다.
	하향식: 큰 작업을 작은 하위작업으로 분해한다/ 모듈들은 개별적으로 처리된다./ 중복정보가 포함될 수 있다/ 주로 구조 절차중심프로그래밍 언어가 하향식 방식을 이용한다.

(3) 설계
입력과 연산을 고려한다.
입력의 경우에는 추상데이터타입(ADT->1.4절) 연산의 경우에는 알고리즘명세와 알고리즘설계 기법 고려해야한다.

(4) 정제와 코딩
수행되는 알고리즘들을 작성한다
수행하는 작업들의 순서가 중요하다. 
좀더 좋은 프로젝트에서 설계의 중요성 (변화를 잘 수용할 수 있는)

(5) 검증
정확성증명: 수학에서 사용하는 기법들을 사용
테스트: 테스트 데이터와 실제로 수행가능한 코드를 필요로 한다.
오류제거: 오류제거의 용이성 스파게티코드/ 프로그램단위들을 별도로 테스트 하고 전체 시스템으로 통합한다면 효과적



## 1.2 포인터와 동적메모리 할당

- 포인터
  
  - & : 주소 연산자
  - \*  : 역참조 연산자
  
  포인터가 실제로 어떤 대상을 가리키고 있지 않을 때는 값을 전부 NULL로 설정하기 
  
- 동적메모리 할당

<details>
  <summary>일반함수와 매크로함수 차이</summary>
  <div markdown="1">
    일반함수는 자료형을 기재하나 매크로 함수는 자료형을 기재하지 않는다<br>
    컴파일 속도는 느리나 실행속도는 빠르다<br>
    일반함수는 컴파일러에 의해 매크로는 전처리기에 의해<br>
  </div>
</details>



## 1.3 알고리즘 명세

알고리즘의 조건

1. **입력(input)**: 입력은 없거나 하나 이상 존재할 수 있다.
2. **출력(output)**: 출력은 반드시 하나 이상 존재해야한다.
3. **명확성(unambiguity)**: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
4. **유한성(finiteness)**: 반드시 유한 시간 이내에 종료되어야한다.
5. **효과성/유효성(effectiveness)**: 각 명령어는 기본적이면서 단순해야 하고 컴퓨터에 의해 실행 가능해야 한다.



## 1.4 데이터 추상화

- 데이터 타입: 객체와 그 객체 위에 작동하는 연산의 집합

- (추가하기) 각 데이터 타입이 차지하는 공간, 자료형의 종류

  - 자바 자료형-> primitive type(정수, 실수, 문자, 논리) | reference type(클래스, 배열, 인터페이스)

  - 파이썬 자료형 -> 동적타입언어(명시적으로 자료형을 선언하지 않는다.) -> 수치자료형, 불자료형, 군집 자료형
    https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt

- 추상 데이터 타입(ADT): 객체의 명세와 그 연산의 명세가 그 객체의 표현과 연산의 구현으로부터 분리된 데이터타입 --> 이부분 다시 보기

  - Creater/ constructor: 함수는 지정된 타입에 맞는 새로운 인스턴스를 생성

  - transformer: 1개 이상의 다른 인스턴스를 이용하여 지정된 타입의 한 인스턴스를 만든다
  - observers/reporter: 데이터 타입의 인스턴스에 대한 정보를 제공한다

  

## 1.5 성능 분석

프로그램을 판단하는 기준들

1) 프로그램이 원래의 명세와 부합?
2) 정확하게 작동
3) 프로그램을 어떻게 사용하고 어떻게 수행하는지에 관한 문서화가 프로그램 내에 되어져 있는가
4) 논리적 단위를 생성하기 위해 프로그램이 함수를 효과적으로 사용하는가
5) 프로그램 코드는 읽기 쉬운가
6) (추가) 메인메모리와 보조기억장치를 효율적으로 사용
7) (추가) 작업에 대한 프로그램의 실행 시간은 허용할 만 한가

- 성능분석은-> 컴퓨터와 상관없이 시공간의 추산에 초점을 둠

- 성능측정은-> 컴퓨터에 의존적인 실행시간을 얻어내는것 -> 1.6절

### 성능분석

- 공간 복잡도: 프로그램을 실행시켜 완료하는 데 필요로 하는 공간의 양
  
  - 고정공간요구: 프로그램 입출력의 횟수나 크기와 관계없는 공간 요구
    명령어공간(코드저장을 위한 공간), 단순 변수, 고정크기의 구조화변수, 상수들을 위한 공간
  
  - 가변 공간 요구: 문제의 특정 인스턴스에 의존하는 크기를 가진 구조화 변수들을 위한 필요로 하는 공간들로 구성
    입출력의 횟수, 크기, 값 등
  
- 시간 복잡도: 프로그램을 실행시켜 완료하는데 필요한 컴퓨터 시간의 양
  
  - 컴파일 시간
  - 실행시간
  - 시간 복잡도는 프로그램의 기능을 수행하기 위해 프로그램이 취한 단계수로 표현된다
  
- 점근표기법

  - Big-Oh

    O(f(n)): 최고차항의 차수가 f(n)과 일치하거나 더 작은 함수들의 집합(최악의 경우) -> 가장 많이 쓰인다고 함

  - Big-Omega

    Ω(f(n)): 최고차항의 차수가 f(n)과 일치하거나 더 큰 함수들의 집합(최선의 경우)

  - Theta

    Θ(f(n)): 최고차항의 차수가 f(n)과 일치하는 함수들의 집합(최선과 최악의 중간)

- 실용적 복잡도

  파이썬 1초 연산 횟수 2천만(20,000,000)~1억(1000,000,000)정도 (N의 범위에 따라 알고리즘 선택)
  int의 경우에는 리스트 길이가 100만(1,000,000)개일때 4mb정도 (데이터개수가 천만(10,000,000)이상이 넘어가지 않도록)

## 1.6 성능 측정

시간 측정법

~~~ python
# python
import time
start_time = time.time() # 측정 시작

# 프로그램 소스코드

end_time = time.time() # 측정 종료
print("time:", end_time - start_time) # 수행 시간 출력
~~~

~~~ java
// java
long startTime = System.currentTimeMillis(); // 측정 시작

// 프로그램 소스 코드

long endTime = System.currentTimeMillis(); //측정 종료
System.out.println("time: " + (endTime - startTime)); // 수행 시간 출력
~~~





<details>
  <summary>참고자료</summary>
  <div markdown="1">
    Fundamentals of Data Structures in C<br>
    https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt<br>
  </div>
</details>



